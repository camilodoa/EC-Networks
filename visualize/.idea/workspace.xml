<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="0e5c5f72-82dc-4685-a1d6-e2d490a652a1" name="Default Changelist" comment="">
      <change afterPath="$PROJECT_DIR$/.idea/encodings.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__bouncycastle_bcmail_jdk14_138.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__bouncycastle_bcprov_jdk14_138.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_lowagie_itext_2_1_7.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_bouncycastle_bcmail_jdk14_1_38.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_bouncycastle_bcprov_jdk14_1_38.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_bouncycastle_bctsp_jdk14_1_38.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__quil_2_4_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__quil_gluegen_rt_fat_2_3_2.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__quil_jogl_all_fat_2_3_2.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__quil_processing_core_3_0_2.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__quil_processing_dxf_3_0_2_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__quil_processing_js_1_4_16_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__quil_processing_pdf_3_0_2.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/vcs.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../deig/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/../deig/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/project.clj" beforeDir="false" afterPath="$PROJECT_DIR$/project.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/visualize.iml" beforeDir="false" afterPath="$PROJECT_DIR$/visualize.iml" afterDir="false" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="DepsLocalSettings">
    <option name="repoId" value="" />
    <option name="repoUrl" value="" />
  </component>
  <component name="FileEditorManager">
    <leaf>
      <file pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/visualize/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="563">
              <caret line="49" column="21" lean-forward="true" selection-start-line="49" selection-start-column="21" selection-end-line="49" selection-end-column="21" />
            </state>
          </provider>
        </entry>
      </file>
      <file pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="136">
              <caret line="8" lean-forward="true" selection-start-line="8" selection-end-line="8" />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/project.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds" extendedState="6">
    <option name="x" value="1037" />
    <option name="y" value="140" />
    <option name="width" value="2348" />
    <option name="height" value="1505" />
  </component>
  <component name="ProjectId" id="1aUM8jFa9xTzhNXHroNEfiPcDJr" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectView">
    <navigator proportions="" version="1">
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="Scope" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="visualize" type="b2602c69:ProjectViewProjectNode" />
              <item name="visualize" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="visualize" type="b2602c69:ProjectViewProjectNode" />
              <item name="visualize" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="visualize" type="b2602c69:ProjectViewProjectNode" />
              <item name="visualize" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="visualize" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="visualize" type="b2602c69:ProjectViewProjectNode" />
              <item name="visualize" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="PackagesPane" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="com.android.tools.idea.instantapp.provision.ProvisionBeforeRunTaskProvider.myTimeStamp" value="1586909912746" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="settings.editor.selected.configurable" value="DepsSettings" />
  </component>
  <component name="ReplState" timestamp="1586909922059">{:repl-history {:ide [], :local [{:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] (vec (repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (def i 5)\n  (when (&gt; i 0)\n    (let [pixels (create-greyscale-pixels [rand-int 4])\n          num (rand-int viz-width)\n          scale-x ((- viz-width (* 2 viz-border)))\n          scale-y ((- viz-height (* 2 viz-border)))]\n      (q/color-mode :rgb 255)\n      (q/background 255)\n      ;; produce text in the window with code such as the following\n      ;(q/fill 0)\n      ;(q/text (str \&quot;Generation: \&quot; gen) 10 20)\n      (q/color-mode :hsb)\n      (doseq [[g errs] (map vector (iterate inc 0) pixels)]\n        (doseq [[i e] (map vector (iterate inc 0) errs)]\n          (q/no-stroke)\n          (q/fill (* i (/ 255 num)) 255 255 64)\n          (q/ellipse (+ viz-border (* g scale-x))\n                     (- viz-height viz-border (* e scale-y))\n                     20\n                     20))))\n    (- i 1)))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n;(start-visualization)\n&quot;, :offset 3577, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] (vec (repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (def i 1)\n  (when (&gt; i 0)\n      (let [pixels (create-greyscale-pixels [rand-int 4])\n            num (rand-int viz-width)\n            scale-x ((- viz-width (* 2 viz-border)))\n            scale-y ((- viz-height (* 2 viz-border)))]\n        (q/color-mode :rgb 255)\n        (q/background 255)\n        ;; produce text in the window with code such as the following\n        (q/fill 0)\n        (q/text (str \&quot;Generation: \&quot; gen) 10 20)\n        (q/color-mode :hsb)\n        (doseq [[g errs] (map vector (iterate inc 0) pixels)]\n          (doseq [[i e] (map vector (iterate inc 0) errs)]\n            (q/no-stroke)\n            (q/fill (* i (/ 255 num)) 255 255 64)\n            (q/ellipse (+ viz-border (* g scale-x))\n                       (- viz-height viz-border (* e scale-y))\n                       20\n                       20))))\n      (- i 1)))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 3612, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] (vec (repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (def i 1)\n  (when (&gt; i 0)\n    (let [pixels (create-greyscale-pixels [rand-int 4])\n          num (rand-int viz-width)\n          scale-x ((- viz-width (* 2 viz-border)))\n          scale-y ((- viz-height (* 2 viz-border)))]\n      (q/color-mode :rgb 255)\n      (q/background 255)\n      ;; produce text in the window with code such as the following\n      (q/fill 0)\n      (q/text (str \&quot;Generation: \&quot; gen) 10 20)\n      (q/color-mode :hsb)\n      (doseq [[g errs] (map vector (iterate inc 0) pixels)]\n        (doseq [[i e] (map vector (iterate inc 0) errs)]\n          (q/no-stroke)\n          (q/fill (* i (/ 255 num)) 255 255 64)\n          (q/ellipse (+ viz-border (* g scale-x))\n                     (- viz-height viz-border (* e scale-y))\n                     20\n                     20))))\n    (- i 1)))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))&quot;, :offset 3497, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] (vec (repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (def i 1)\n  (when (&gt; i 0)\n    (let [pixels (create-greyscale-pixels [rand-int 4])\n          num (rand-int viz-width)\n          scale-x ((- viz-width (* 2 viz-border)))\n          scale-y ((- viz-height (* 2 viz-border)))]\n      (q/color-mode :rgb 255)\n      (q/background 255)\n      ;; produce text in the window with code such as the following\n      (q/fill 0)\n      (q/text (str \&quot;Generation: \&quot; i) 10 20)\n      (q/color-mode :hsb)\n      (doseq [[g errs] (map vector (iterate inc 0) pixels)]\n        (doseq [[i e] (map vector (iterate inc 0) errs)]\n          (q/no-stroke)\n          (q/fill (* i (/ 255 num)) 255 255 64)\n          (q/ellipse (+ viz-border (* g scale-x))\n                     (- viz-height viz-border (* e scale-y))\n                     20\n                     20))))\n    (- i 1)))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 3572, :ns &quot;visualize.core&quot;} {:command &quot;(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (def i 5)\n  (when (&gt; i 0)\n    (let [num (rand-int 5)\n          scale-x ((- viz-width (* 2 viz-border)))\n          scale-y ((- viz-height (* 2 viz-border)))]\n      (q/color-mode :rgb 255)\n      (q/background 255)\n      ;; produce text in the window with code such as the following\n      (q/fill 0)\n      (q/text (str \&quot;Generation: \&quot; i) 10 20)\n      (q/color-mode :hsb)\n\n      (q/no-stroke)\n      (q/fill (* i (/ 255 num)) 255 255 64)\n      (q/ellipse (+ viz-border (* 5 scale-x))\n                 (- viz-height viz-border (* 5 scale-y))\n                 20\n                 20))\n    (- i 1)))&quot;, :offset 1036, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image 1200 1200 :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int 1000))\n            j (range (rand-int 1000))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int 1200) (rand-int 1200)\n                   (q/color (rand-int 256) (rand-int 256) (rand-int 256) (rand-int 256))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n;(start-visualization)\n&quot;, :offset 3197, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1200) ;; width of the visualization window in pixels\n(def viz-height 1200) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image 1200 1200 :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int 1000))\n            j (range (rand-int 1000))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int 1200) (rand-int 1200)\n                   (q/color (rand-int 256) (rand-int 256) (rand-int 256) (rand-int 256))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 3196, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 600) ;; width of the visualization window in pixels\n(def viz-height 600) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image 1200 1200 :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int 1000))\n            j (range (rand-int 1000))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int 1200) (rand-int 1200)\n                   (q/color (rand-int 256) (rand-int 256) (rand-int 256) (rand-int 256))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 3194, :ns &quot;visualize.core&quot;} {:command &quot;(* viz-width 2)&quot;, :offset 15, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))\n\n(def viz-width 600) ;; width of the visualization window in pixels\n(def viz-height 600) ;; height of the visualization window in pixels\n(def num_pixels 700) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int num_pixels))\n            j (range (rand-int num_pixels))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int (* viz-width 2)) (rand-int (* viz-width 2))\n                   (q/color (rand-int 255) (rand-int 255) (rand-int 255) (rand-int 255))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 1307, :ns &quot;visualize.core&quot;} {:command &quot;(def num_pixels 1000)&quot;, :offset 21, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))\n\n(def viz-width 600) ;; width of the visualization window in pixels\n(def viz-height 600) ;; height of the visualization window in pixels\n(def num_pixels 1000) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn rand_pixels []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int num_pixels))\n            j (range (rand-int num_pixels))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int (* viz-width 2)) (rand-int (* viz-width 2))\n                   (q/color (rand-int 255) (rand-int 255) (rand-int 255) (rand-int 255))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw rand_pixels))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 1312, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    (q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n    (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n    (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n    (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100\n          x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n          y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n      (q/ellipse x y diam diam)))\n  (q/set-image 0 0 im)\n  (q/no-loop))&quot;, :offset 704, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n\n  (q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n  (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n  (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n  (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100\n        x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n        y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n    (q/ellipse x y diam diam)))&quot;, :offset 555, :ns &quot;visualize.core&quot;} {:command &quot;(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw rand_ellipse))&quot;, :offset 253, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n\n    (q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n    (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n    (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n    (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100\n          x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n          y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n      (q/ellipse x y diam diam))\n    (q/no-loop))&quot;, :offset 585, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n\n    (q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n    (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n    (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n    (let [diam (q/random viz-width)             ;; Set the diameter to a value between 0 and 100\n          x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n          y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n      (q/ellipse x y diam diam))\n    (q/no-loop))\n&quot;, :offset 592, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))             ;; Set the stroke colour to a random grey\n    (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))               ;; Set the fill colour to a random grey\n\n    (let [diam (q/random viz-width)             ;; Set the diameter to a value between 0 and 100\n          x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n          y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n      (q/ellipse x y diam diam))\n    (q/no-loop))&quot;, :offset 681, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))             ;; Set the stroke colour to a random grey\n    (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))               ;; Set the fill colour to a random grey\n\n    (let [diam (q/random viz-width)             ;; Set the diameter to a value between 0 and 100\n          x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n          y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n      (q/ellipse x y diam diam))\n    )&quot;, :offset 670, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random viz-width))\n  (when (&gt; i 0)\n    (let [gr (q/background 255)]\n      (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255)) \n      (q/stroke-weight (q/random 10))                      \n      (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255)) \n\n      (let [diam (q/random viz-width)                        \n            x (q/random (q/width))                            \n            y (q/random (q/height))]                          \n        (q/ellipse x y diam diam)))\n      (- i 1)))&quot;, :offset 556, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (when (&gt; i 0)\n    (let [gr (q/background 255)]\n      (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n      (q/stroke-weight (q/random 10))\n      (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n      (let [diam (q/random viz-width)\n            x (q/random (q/width))\n            y (q/random (q/height))]\n        (q/ellipse x y diam diam)))\n      (- i 1)))&quot;, :offset 446, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (rand-int 5))\n  (when (&gt; i 0)\n    (let [gr (q/background 255)]\n      (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n      (q/stroke-weight (q/random 10))\n      (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n      (let [diam (q/random viz-width)\n            x (q/random (q/width))\n            y (q/random (q/height))]\n        (q/ellipse x y diam diam)))\n      (- i 1)))&quot;, :offset 446, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (when (&gt; i 0)\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam)))\n  (- i 1))&quot;, :offset 394, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (while (&gt; i 0)\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam)))\n  (- i 1))&quot;, :offset 395, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (while (&gt; i 0)\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam))\n    (- i 1)))&quot;, :offset 397, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (loop (&gt; i 0)\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam))\n    (- i 1)))&quot;, :offset 396, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (loop [(&gt; i 0)]\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam))\n    (- i 1)))&quot;, :offset 398, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (while (&gt; i 0)\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam))))&quot;, :offset 385, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (while (&gt; i 0)\n    (do\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam)))))&quot;, :offset 394, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (print i)\n  (while (&gt; i 0)\n    (do\n      (print i)\n      (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n      (q/stroke-weight (q/random 10))\n      (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n      (let [diam (q/random viz-width)\n            x (q/random (q/width))\n            y (q/random (q/height))]\n        (q/ellipse x y diam diam)))))&quot;, :offset 436, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (print i)\n  (while (&gt; i 0)\n    (do\n      (print i)\n      (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n      (q/stroke-weight (q/random 10))\n      (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n      (let [diam (q/random viz-width)\n            x (q/random (q/width))\n            y (q/random (q/height))]\n        (q/ellipse x y diam diam))\n      (swap! i dec))))&quot;, :offset 456, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (print i)\n  (def a (atom 10))\n  ;; #'user/a\n\n  (while (pos? @a) (do (println @a) (swap! a dec))))&quot;, :offset 144, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  \n  (def a (atom 10))\n  ;; #'user/a\n\n  (while (pos? @a) (do (println @a) (swap! a dec))))&quot;, :offset 112, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))\n\n(def viz-width 600) ;; width of the visualization window in pixels\n(def viz-height 600) ;; height of the visualization window in pixels\n(def num_pixels 1000) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn rand_pixels []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int num_pixels))\n            j (range (rand-int num_pixels))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int (* viz-width 2)) (rand-int (* viz-width 2))\n                   (q/color (rand-int 255) (rand-int 255) (rand-int 255) (rand-int 255))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n\n(defn rand_ellipse []\n\n  (def a (atom 10))\n  ;; #'user/a\n\n  (while (pos? @a) (do (println @a) (swap! a dec))))\n\n;(while (&lt; i 0)\n;  (do\n;    (print i)\n;    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n;    (q/stroke-weight (q/random 10))\n;    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n;\n;    (let [diam (q/random viz-width)\n;          x (q/random (q/width))\n;          y (q/random (q/height))]\n;      (q/ellipse x y diam diam))\n;    (dec i))))\n\n\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw rand_ellipse))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 1813, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))\n\n(def viz-width 600) ;; width of the visualization window in pixels\n(def viz-height 600) ;; height of the visualization window in pixels\n(def num_pixels 1000) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn rand_pixels []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int num_pixels))\n            j (range (rand-int num_pixels))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int (* viz-width 2)) (rand-int (* viz-width 2))\n                   (q/color (rand-int 255) (rand-int 255) (rand-int 255) (rand-int 255))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n\n(defn rand_ellipse []\n\n  (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n  (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n  (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n  (let [diam (q/random viz-width)\n        x    (q/random (q/width))\n        y    (q/random (q/height))]\n    (q/ellipse x y diam diam))\n  (q/no-loop))\n\n\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw rand_pixels))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 1711, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))\n\n(def viz-width 28) ;; width of the visualization window in pixels\n(def viz-height 28) ;; height of the visualization window in pixels\n(def num_pixels 200) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn rand_pixels []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int num_pixels))\n            j (range (rand-int num_pixels))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int (* viz-width 2)) (rand-int (* viz-width 2))\n                   (q/color (rand-int 255) (rand-int 255) (rand-int 255) (rand-int 255))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n\n(defn rand_ellipse []\n\n  (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n  (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n  (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n  (let [diam (q/random viz-width)\n        x    (q/random (q/width))\n        y    (q/random (q/height))]\n    (q/ellipse x y diam diam))\n  (q/no-loop))\n\n\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw rand_pixels))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 1708, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))&quot;, :offset 50, :ns &quot;visualize.core&quot;} {:command &quot;(start-visualization)&quot;, :offset 21, :ns &quot;visualize.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.REPL for visualize">
    <configuration name="REPL for visualize" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false" temporary="true">
      <module name="visualize" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="SOCKET" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration name="visualize.core" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="visualize" />
      <setting name="path" value="$PROJECT_DIR$/src/visualize/core.clj" />
      <setting name="namespace" value="" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$/src/visualize" />
      <method v="2" />
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="Clojure REPL.REPL for visualize" />
        <item itemvalue="Clojure Application.visualize.core" />
      </list>
    </recent_temporary>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="0e5c5f72-82dc-4685-a1d6-e2d490a652a1" name="Default Changelist" comment="" />
      <created>1586785561303</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1586785561303</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="-6" y="-6" width="1549" height="837" extended-state="6" />
    <editor active="true" />
    <layout>
      <window_info id="Image Layers" />
      <window_info id="Designer" />
      <window_info id="UI Designer" />
      <window_info id="Capture Tool" />
      <window_info id="Favorites" side_tool="true" />
      <window_info content_ui="combo" id="Project" order="0" visible="true" weight="0.24949698" />
      <window_info id="Structure" order="1" side_tool="true" weight="0.25" />
      <window_info anchor="bottom" id="Version Control" />
      <window_info anchor="bottom" id="Terminal" />
      <window_info anchor="bottom" id="Event Log" side_tool="true" />
      <window_info anchor="bottom" id="Message" order="0" />
      <window_info anchor="bottom" id="Find" order="1" />
      <window_info anchor="bottom" id="Run" order="2" weight="0.32956153" />
      <window_info anchor="bottom" id="Debug" order="3" weight="0.4" />
      <window_info anchor="bottom" id="Cvs" order="4" weight="0.25" />
      <window_info anchor="bottom" id="Inspection" order="5" weight="0.4" />
      <window_info anchor="bottom" id="TODO" order="6" />
      <window_info anchor="right" id="Palette" />
      <window_info anchor="right" id="REPL" side_tool="true" weight="0.30449364" />
      <window_info anchor="right" id="Theme Preview" />
      <window_info anchor="right" id="Maven" />
      <window_info anchor="right" id="Leiningen" />
      <window_info anchor="right" id="Capture Analysis" />
      <window_info anchor="right" id="Palette&#9;" />
      <window_info anchor="right" id="Commander" internal_type="SLIDING" order="0" type="SLIDING" weight="0.4" />
      <window_info anchor="right" id="Ant Build" order="1" weight="0.25" />
      <window_info anchor="right" content_ui="combo" id="Hierarchy" order="2" weight="0.25" />
    </layout>
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="136">
          <caret line="8" lean-forward="true" selection-start-line="8" selection-end-line="8" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/visualize/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="563">
          <caret line="49" column="21" lean-forward="true" selection-start-line="49" selection-start-column="21" selection-end-line="49" selection-end-column="21" />
        </state>
      </provider>
    </entry>
  </component>
</project>