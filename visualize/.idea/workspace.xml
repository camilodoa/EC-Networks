<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="0e5c5f72-82dc-4685-a1d6-e2d490a652a1" name="Default Changelist" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/visualize/core.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/visualize/core.clj" afterDir="false" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="DepsLocalSettings">
    <option name="repoId" value="" />
    <option name="repoUrl" value="" />
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="ProjectId" id="1aUM8jFa9xTzhNXHroNEfiPcDJr" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="PropertiesComponent">
    <property name="com.android.tools.idea.instantapp.provision.ProvisionBeforeRunTaskProvider.myTimeStamp" value="1586909912746" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="settings.editor.selected.configurable" value="DepsSettings" />
  </component>
  <component name="ReplState" timestamp="1587397232349">{:repl-history {:ide [], :local [{:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] (vec (repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (def i 5)\n  (when (&gt; i 0)\n    (let [pixels (create-greyscale-pixels [rand-int 4])\n          num (rand-int viz-width)\n          scale-x ((- viz-width (* 2 viz-border)))\n          scale-y ((- viz-height (* 2 viz-border)))]\n      (q/color-mode :rgb 255)\n      (q/background 255)\n      ;; produce text in the window with code such as the following\n      ;(q/fill 0)\n      ;(q/text (str \&quot;Generation: \&quot; gen) 10 20)\n      (q/color-mode :hsb)\n      (doseq [[g errs] (map vector (iterate inc 0) pixels)]\n        (doseq [[i e] (map vector (iterate inc 0) errs)]\n          (q/no-stroke)\n          (q/fill (* i (/ 255 num)) 255 255 64)\n          (q/ellipse (+ viz-border (* g scale-x))\n                     (- viz-height viz-border (* e scale-y))\n                     20\n                     20))))\n    (- i 1)))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n;(start-visualization)\n&quot;, :offset 3577, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] (vec (repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (def i 1)\n  (when (&gt; i 0)\n      (let [pixels (create-greyscale-pixels [rand-int 4])\n            num (rand-int viz-width)\n            scale-x ((- viz-width (* 2 viz-border)))\n            scale-y ((- viz-height (* 2 viz-border)))]\n        (q/color-mode :rgb 255)\n        (q/background 255)\n        ;; produce text in the window with code such as the following\n        (q/fill 0)\n        (q/text (str \&quot;Generation: \&quot; gen) 10 20)\n        (q/color-mode :hsb)\n        (doseq [[g errs] (map vector (iterate inc 0) pixels)]\n          (doseq [[i e] (map vector (iterate inc 0) errs)]\n            (q/no-stroke)\n            (q/fill (* i (/ 255 num)) 255 255 64)\n            (q/ellipse (+ viz-border (* g scale-x))\n                       (- viz-height viz-border (* e scale-y))\n                       20\n                       20))))\n      (- i 1)))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 3612, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] (vec (repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (def i 1)\n  (when (&gt; i 0)\n    (let [pixels (create-greyscale-pixels [rand-int 4])\n          num (rand-int viz-width)\n          scale-x ((- viz-width (* 2 viz-border)))\n          scale-y ((- viz-height (* 2 viz-border)))]\n      (q/color-mode :rgb 255)\n      (q/background 255)\n      ;; produce text in the window with code such as the following\n      (q/fill 0)\n      (q/text (str \&quot;Generation: \&quot; gen) 10 20)\n      (q/color-mode :hsb)\n      (doseq [[g errs] (map vector (iterate inc 0) pixels)]\n        (doseq [[i e] (map vector (iterate inc 0) errs)]\n          (q/no-stroke)\n          (q/fill (* i (/ 255 num)) 255 255 64)\n          (q/ellipse (+ viz-border (* g scale-x))\n                     (- viz-height viz-border (* e scale-y))\n                     20\n                     20))))\n    (- i 1)))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))&quot;, :offset 3497, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] (vec (repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (def i 1)\n  (when (&gt; i 0)\n    (let [pixels (create-greyscale-pixels [rand-int 4])\n          num (rand-int viz-width)\n          scale-x ((- viz-width (* 2 viz-border)))\n          scale-y ((- viz-height (* 2 viz-border)))]\n      (q/color-mode :rgb 255)\n      (q/background 255)\n      ;; produce text in the window with code such as the following\n      (q/fill 0)\n      (q/text (str \&quot;Generation: \&quot; i) 10 20)\n      (q/color-mode :hsb)\n      (doseq [[g errs] (map vector (iterate inc 0) pixels)]\n        (doseq [[i e] (map vector (iterate inc 0) errs)]\n          (q/no-stroke)\n          (q/fill (* i (/ 255 num)) 255 255 64)\n          (q/ellipse (+ viz-border (* g scale-x))\n                     (- viz-height viz-border (* e scale-y))\n                     20\n                     20))))\n    (- i 1)))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 3572, :ns &quot;visualize.core&quot;} {:command &quot;(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (def i 5)\n  (when (&gt; i 0)\n    (let [num (rand-int 5)\n          scale-x ((- viz-width (* 2 viz-border)))\n          scale-y ((- viz-height (* 2 viz-border)))]\n      (q/color-mode :rgb 255)\n      (q/background 255)\n      ;; produce text in the window with code such as the following\n      (q/fill 0)\n      (q/text (str \&quot;Generation: \&quot; i) 10 20)\n      (q/color-mode :hsb)\n\n      (q/no-stroke)\n      (q/fill (* i (/ 255 num)) 255 255 64)\n      (q/ellipse (+ viz-border (* 5 scale-x))\n                 (- viz-height viz-border (* 5 scale-y))\n                 20\n                 20))\n    (- i 1)))&quot;, :offset 1036, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1000) ;; width of the visualization window in pixels\n(def viz-height 1000) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image 1200 1200 :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int 1000))\n            j (range (rand-int 1000))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int 1200) (rand-int 1200)\n                   (q/color (rand-int 256) (rand-int 256) (rand-int 256) (rand-int 256))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n;(start-visualization)\n&quot;, :offset 3197, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 1200) ;; width of the visualization window in pixels\n(def viz-height 1200) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image 1200 1200 :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int 1000))\n            j (range (rand-int 1000))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int 1200) (rand-int 1200)\n                   (q/color (rand-int 256) (rand-int 256) (rand-int 256) (rand-int 256))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 3196, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n\n  (:require [quil.core :as q]))\n\n;; This file demonstrates how one can produce a visualization of the status of a\n;; pushgp run as it proceeds. It can be invoked by specifying \&quot;:visualize true\&quot;\n;; in the argument map, or in a command line such as:\n\n;; lein run clojush.problems.demos.simple-regression :parent-selection :lexicase :visualize true\n\n;; The default behavior is not intended to be particularly general or useful, but\n;; just to provide a demonstration that can serve as a base upon which more general\n;; visualization systems or specialized visualizations for particular problems and\n;; research questions can be built.\n\n;; That said, the default behavior is to plot all of the errors (for all test cases,\n;; individually) on the y axis, for the best (lowest total error) individual in each\n;; generation, with generations running across the x axis. Errors are plotted as\n;; colored circles, with colors chosen arbitrarily to span the range of hues in a\n;; hue-saturation-brightness color encoding. Transparency is used to make overlaps\n;; visible to some extent. The x and y axes are scaled dynamically over the run.\n\n;; The system works by launching a Quil/Processing (http://quil.info) \&quot;sketch\&quot; and\n;; having that sketch run concurrently with the pushgp run. A Clojure atom, called\n;; viz-data-atom (created in clojush.globals), is used to communicate between pushgp\n;; and the Quil sketch.\n\n;; The initial value of viz-data-atom is set set below, in start-visualization.\n;; By default it contains a map with keys only for :generation and\n;; :history-of-errors-of-best, but this can be extended as you wish.\n\n;; Updates to viz-data-atom should be made in report-and-check-for-success, in\n;; clojush.pushgp.report -- search for viz-data-atom in src/clojush/pushgp/report.clj\n;; to find the code to customize there.\n\n;; The actual visualization code is in the visualize function below, and should use\n;; Quil functions to render the infromation in viz-data-atom.\n\n(def viz-width 600) ;; width of the visualization window in pixels\n(def viz-height 600) ;; height of the visualization window in pixels\n(def viz-border 50) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image 1200 1200 :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int 1000))\n            j (range (rand-int 1000))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int 1200) (rand-int 1200)\n                   (q/color (rand-int 256) (rand-int 256) (rand-int 256) (rand-int 256))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 3194, :ns &quot;visualize.core&quot;} {:command &quot;(* viz-width 2)&quot;, :offset 15, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))\n\n(def viz-width 600) ;; width of the visualization window in pixels\n(def viz-height 600) ;; height of the visualization window in pixels\n(def num_pixels 700) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn visualize []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int num_pixels))\n            j (range (rand-int num_pixels))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int (* viz-width 2)) (rand-int (* viz-width 2))\n                   (q/color (rand-int 255) (rand-int 255) (rand-int 255) (rand-int 255))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw visualize))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 1307, :ns &quot;visualize.core&quot;} {:command &quot;(def num_pixels 1000)&quot;, :offset 21, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))\n\n(def viz-width 600) ;; width of the visualization window in pixels\n(def viz-height 600) ;; height of the visualization window in pixels\n(def num_pixels 1000) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn rand_pixels []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int num_pixels))\n            j (range (rand-int num_pixels))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int (* viz-width 2)) (rand-int (* viz-width 2))\n                   (q/color (rand-int 255) (rand-int 255) (rand-int 255) (rand-int 255))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw rand_pixels))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 1312, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    (q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n    (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n    (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n    (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100\n          x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n          y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n      (q/ellipse x y diam diam)))\n  (q/set-image 0 0 im)\n  (q/no-loop))&quot;, :offset 704, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n\n  (q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n  (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n  (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n  (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100\n        x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n        y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n    (q/ellipse x y diam diam)))&quot;, :offset 555, :ns &quot;visualize.core&quot;} {:command &quot;(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw rand_ellipse))&quot;, :offset 253, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n\n    (q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n    (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n    (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n    (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100\n          x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n          y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n      (q/ellipse x y diam diam))\n    (q/no-loop))&quot;, :offset 585, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n\n    (q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n    (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n    (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n    (let [diam (q/random viz-width)             ;; Set the diameter to a value between 0 and 100\n          x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n          y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n      (q/ellipse x y diam diam))\n    (q/no-loop))\n&quot;, :offset 592, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))             ;; Set the stroke colour to a random grey\n    (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))               ;; Set the fill colour to a random grey\n\n    (let [diam (q/random viz-width)             ;; Set the diameter to a value between 0 and 100\n          x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n          y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n      (q/ellipse x y diam diam))\n    (q/no-loop))&quot;, :offset 681, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))             ;; Set the stroke colour to a random grey\n    (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))               ;; Set the fill colour to a random grey\n\n    (let [diam (q/random viz-width)             ;; Set the diameter to a value between 0 and 100\n          x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n          y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n      (q/ellipse x y diam diam))\n    )&quot;, :offset 670, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random viz-width))\n  (when (&gt; i 0)\n    (let [gr (q/background 255)]\n      (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255)) \n      (q/stroke-weight (q/random 10))                      \n      (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255)) \n\n      (let [diam (q/random viz-width)                        \n            x (q/random (q/width))                            \n            y (q/random (q/height))]                          \n        (q/ellipse x y diam diam)))\n      (- i 1)))&quot;, :offset 556, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (when (&gt; i 0)\n    (let [gr (q/background 255)]\n      (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n      (q/stroke-weight (q/random 10))\n      (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n      (let [diam (q/random viz-width)\n            x (q/random (q/width))\n            y (q/random (q/height))]\n        (q/ellipse x y diam diam)))\n      (- i 1)))&quot;, :offset 446, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (rand-int 5))\n  (when (&gt; i 0)\n    (let [gr (q/background 255)]\n      (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n      (q/stroke-weight (q/random 10))\n      (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n      (let [diam (q/random viz-width)\n            x (q/random (q/width))\n            y (q/random (q/height))]\n        (q/ellipse x y diam diam)))\n      (- i 1)))&quot;, :offset 446, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (when (&gt; i 0)\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam)))\n  (- i 1))&quot;, :offset 394, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (while (&gt; i 0)\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam)))\n  (- i 1))&quot;, :offset 395, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (while (&gt; i 0)\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam))\n    (- i 1)))&quot;, :offset 397, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (loop (&gt; i 0)\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam))\n    (- i 1)))&quot;, :offset 396, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (loop [(&gt; i 0)]\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam))\n    (- i 1)))&quot;, :offset 398, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (while (&gt; i 0)\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam))))&quot;, :offset 385, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (while (&gt; i 0)\n    (do\n    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n    (q/stroke-weight (q/random 10))\n    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n    (let [diam (q/random viz-width)\n          x (q/random (q/width))\n          y (q/random (q/height))]\n      (q/ellipse x y diam diam)))))&quot;, :offset 394, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (print i)\n  (while (&gt; i 0)\n    (do\n      (print i)\n      (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n      (q/stroke-weight (q/random 10))\n      (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n      (let [diam (q/random viz-width)\n            x (q/random (q/width))\n            y (q/random (q/height))]\n        (q/ellipse x y diam diam)))))&quot;, :offset 436, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (print i)\n  (while (&gt; i 0)\n    (do\n      (print i)\n      (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n      (q/stroke-weight (q/random 10))\n      (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n      (let [diam (q/random viz-width)\n            x (q/random (q/width))\n            y (q/random (q/height))]\n        (q/ellipse x y diam diam))\n      (swap! i dec))))&quot;, :offset 456, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  (def i (q/random 5))\n  (print i)\n  (def a (atom 10))\n  ;; #'user/a\n\n  (while (pos? @a) (do (println @a) (swap! a dec))))&quot;, :offset 144, :ns &quot;visualize.core&quot;} {:command &quot;(defn rand_ellipse []\n  \n  (def a (atom 10))\n  ;; #'user/a\n\n  (while (pos? @a) (do (println @a) (swap! a dec))))&quot;, :offset 112, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))\n\n(def viz-width 600) ;; width of the visualization window in pixels\n(def viz-height 600) ;; height of the visualization window in pixels\n(def num_pixels 1000) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn rand_pixels []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int num_pixels))\n            j (range (rand-int num_pixels))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int (* viz-width 2)) (rand-int (* viz-width 2))\n                   (q/color (rand-int 255) (rand-int 255) (rand-int 255) (rand-int 255))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n\n(defn rand_ellipse []\n\n  (def a (atom 10))\n  ;; #'user/a\n\n  (while (pos? @a) (do (println @a) (swap! a dec))))\n\n;(while (&lt; i 0)\n;  (do\n;    (print i)\n;    (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n;    (q/stroke-weight (q/random 10))\n;    (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n;\n;    (let [diam (q/random viz-width)\n;          x (q/random (q/width))\n;          y (q/random (q/height))]\n;      (q/ellipse x y diam diam))\n;    (dec i))))\n\n\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw rand_ellipse))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 1813, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))\n\n(def viz-width 600) ;; width of the visualization window in pixels\n(def viz-height 600) ;; height of the visualization window in pixels\n(def num_pixels 1000) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn rand_pixels []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int num_pixels))\n            j (range (rand-int num_pixels))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int (* viz-width 2)) (rand-int (* viz-width 2))\n                   (q/color (rand-int 255) (rand-int 255) (rand-int 255) (rand-int 255))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n\n(defn rand_ellipse []\n\n  (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n  (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n  (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n  (let [diam (q/random viz-width)\n        x    (q/random (q/width))\n        y    (q/random (q/height))]\n    (q/ellipse x y diam diam))\n  (q/no-loop))\n\n\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw rand_pixels))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 1711, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))\n\n(def viz-width 28) ;; width of the visualization window in pixels\n(def viz-height 28) ;; height of the visualization window in pixels\n(def num_pixels 200) ;; pixels from centers of edge points to window edge\n\n(defn greyscale-pixel [] (rand-int 255))\n(defn create-greyscale-pixels [dimension] ((repeatedly (* dimension dimension) greyscale-pixel)))\n\n(defn rand_pixels []\n  \&quot;Render the information in viz-data-atom to the visualization window.\&quot;\n  (let [gr (q/background 255)\n        im (q/create-image (* viz-width 2) (* viz-height 2) :rgb)]\n\n    ;; randomly set this many pixels\n    (doseq [i (range (rand-int num_pixels))\n            j (range (rand-int num_pixels))]\n\n      ;; set pixel at random x,y with random color\n      (q/set-pixel im (rand-int (* viz-width 2)) (rand-int (* viz-width 2))\n                   (q/color (rand-int 255) (rand-int 255) (rand-int 255) (rand-int 255))))\n    (q/set-image 0 0 im))\n  (q/no-loop))\n\n\n(defn rand_ellipse []\n\n  (q/stroke (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n  (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n  (q/fill (q/random 255) (q/random 255) (q/random 255) (q/random 255))\n\n  (let [diam (q/random viz-width)\n        x    (q/random (q/width))\n        y    (q/random (q/height))]\n    (q/ellipse x y diam diam))\n  (q/no-loop))\n\n\n\n(defn start-visualization []\n  \&quot;Initialize viz-data-atom and create the Quil sketch.\&quot;\n  ;(reset! viz-data-atom {:generation 0\n  ;                       :history-of-errors-of-best []})\n  (q/sketch\n    :size [viz-width viz-height]\n    :draw rand_pixels))\n\n;; Start the visualization when this file is loaded.\n(start-visualization)\n&quot;, :offset 1708, :ns &quot;visualize.core&quot;} {:command &quot;(ns visualize.core\n  (:require [quil.core :as q]))&quot;, :offset 50, :ns &quot;visualize.core&quot;} {:command &quot;(start-visualization)&quot;, :offset 21, :ns &quot;visualize.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.REPL for visualize">
    <configuration name="REPL for visualize" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false" temporary="true">
      <module name="visualize" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="SOCKET" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="visualize.core" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="visualize" />
      <setting name="path" value="$PROJECT_DIR$/src/visualize/core.clj" />
      <setting name="namespace" value="" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$/src/visualize" />
      <method v="2" />
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="Clojure REPL.REPL for visualize" />
        <item itemvalue="Clojure Application.visualize.core" />
      </list>
    </recent_temporary>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="0e5c5f72-82dc-4685-a1d6-e2d490a652a1" name="Default Changelist" comment="" />
      <created>1586785561303</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1586785561303</updated>
    </task>
    <servers />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State>
              <option name="COLUMN_ORDER" />
            </State>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>